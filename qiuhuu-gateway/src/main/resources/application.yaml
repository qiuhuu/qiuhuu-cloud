#logging:
#  level:
#    root: debug
spring:
  devtools:
    restart:
      additional-paths: src/main/java
      enabled: true
mybatis:
  type-aliases-package: com.qiuhuu.gaetway.domain.entity
  mapper-locations: classpath:mybatis/mapping/*.xml
  config-location: classpath:mybatis/mybatis.xml
management:
  endpoint:
    gateway:
      enabled: true #开启后可以获取每个路由更多详细信息
  endpoints:
    web:
      exposure:
        include: refresh,health,info     #配置actuator 暴露的接入点
feign:
  hystrix:
    enabled: true
#  compression:
#    response:
#      enabled: true
#    request:
#      enabled: true
#      mime-types: text/xml,application/xml.application/json   #压缩支持的mime type
#      min-request-size: 1024         #压缩数据大小的最小值

#ribbon:
#  MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试，如果eureka中找不到服务则直接走断路器
#  MaxAutoRetriesNextServer: 3 #切换实例的重试次数
#  OkToRetryOnAllOperations: false  #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false
#  ConnectTimeout: 5000  #请求连接的超时时间
#  ReadTimeout: 3000 #请求处理的超时时间
### hystrix相关配置
#hystrix:
#  threadpool:
#    # 指定服务的配置
##    user-service:
##      coreSize: 20            # 线程池大小
##      maxQueueSize: 200       # 缓冲区大小， 如果为-1，则不缓冲，直接进行降级 fallback
##      queueSizeRejectionThreshold: 3  # 缓冲区大小超限的阈值，超限就直接降级
#    # userThreadPool是UserTimeOutCommand中配置的threadPoolKey
##    userThreadPool:
##      coreSize: 20
##      maxQueueSize: 20
##      queueSizeRejectionThreshold: 3
#    # 这是默认的配置
#    default:
#      coreSize: 10
#      maxQueueSize: 200
#      queueSizeRejectionThreshold: 2
#  command:
#    # 指定feign客户端中具体的方法
#    UserService#timeout():
#      execution:
#        isolation:
#          thread:
#            timeoutInMilliseconds: 20000
#    userCommandKey:
#      execution:
#        isolation:
#          thread:
#            timeoutInMilliseconds: 15000
#    # 这是默认的配置
#    default:
#      execution:
#        timeout:
#          enabled: true     # 是否打开超时
#        isolation:          # 执行策略
#          strategy: THREAD  # 资源隔离模式，默认thread。 还有一种叫信号量 SEMAPHORE
#          thread:
#            timeoutInMilliseconds: 15000  # 超时时间，默认1000毫秒
#            interruptOnTimeout: true      # 超时时中断线程
#            interruptOnFutureCancel: false  # 取消时候中断线程
#          semaphore:
#            maxConcurrentRequests: 2  # 信号量模式下，最大并发量
#      fallback:         # 降级策略
#        enabled: true   # 是否开启服务降级
#        isolation:
#          semaphore:
#            maxConcurrentRequests: 100 # fallback执行并发量
#      circuitBreaker:       # 熔断策略
#        enabled: true       # 启用/禁用熔断机制
#        forceOpen: false    # 强制开启熔断
#        forceClosed: false  # 强制关闭熔断
#        requestVolumeThreshold: 4   # 前提条件，一定时间内发起一定数量的请求。  也就是5秒钟内(这个5秒对应下面的滚动窗口长度)至少请求4次，熔断器才发挥起作用。  默认20
#        errorThresholdPercentage: 50    # 错误百分比。达到或超过这个百分比，熔断器打开。  比如：5秒内有4个请求，2个请求超时或者失败，就会自动开启熔断
#        sleepWindowInMilliseconds: 10000    # 10秒后，进入半打开状态（熔断开启，间隔一段时间后，会让一部分的命令去请求服务提供者，如果结果依旧是失败，则又会进入熔断状态，如果成功，就关闭熔断）。 默认5秒
#      metrics:  # 度量策略
#        rollingStats:
#          timeInMilliseconds: 5000    # 5秒为一次统计周期，术语描述：滚动窗口的长度为5秒
#          numBuckets: 10      # 统计周期内 度量桶的数量，必须被timeInMilliseconds整除。作用：
#        rollingPercentile:
#          enabled: true       # 是否收集执行时间，并计算各个时间段的百分比
#          timeInMilliseconds: 60000   # 设置执行时间统计周期为多久，用来计算百分比
#          numBuckets: 6       # 执行时间统计周期内，度量桶的数量
#          bucketSize: 100     # 执行时间统计周期内，每个度量桶最多统计多少条记录。设置为50，有100次请求，则只会统计最近的10次
#        healthSnapshot:
#          intervalInMilliseconds: 500   # 数据取样时间间隔